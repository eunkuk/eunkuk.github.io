---
title: "PHP CodeIgniter 프로젝트를 Spring Boot로 옮기기까지 — 마이그레이션 회고 (1) 왜 다시 만들었나"
date: 2026-02-15 22:00:00 +0900
categories: [Dev, Migration]
tags: [php, codeigniter, spring-boot, migration, legacy, retrospective, series]
description: "유전자검사 서비스의 PHP CodeIgniter 프로젝트를 Spring Boot로 마이그레이션한 이유. 12개 API 컨트롤러, 96개 Admin 컨트롤러, 115개 모델의 레거시를 왜 다시 만들어야 했는지 기록한다."
---

> 유전자검사 서비스의 PHP CodeIgniter 프로젝트를 Spring Boot로 마이그레이션한 이유. 12개 API 컨트롤러, 96개 Admin 컨트롤러, 115개 모델의 레거시를 왜 다시 만들어야 했는지 기록한다.

---

## 1. 상황

2026년을 맞아 지난 마이그레이션을 회고해본다.

2025년 10월, 유전자검사 서비스를 운영하는 회사에 입사했다. PHP CodeIgniter로 돌아가는 서비스를 Spring Boot로 전환하기 위해서다. 회사가 마이그레이션을 결정하고, 그 경험이 있는 백엔드 개발자를 찾은 것이다.

팀 구성은 이렇다.

| 역할 | 인원 | 비고 |
|------|------|------|
| 백엔드 개발 | 1 (나) | 마이그레이션 + 서비스 API + 관리자 API |
| 프론트엔드 개발 | 1 | 모바일 앱 + 관리자 웹 |
| 기획 + 디자인 | 1 | 서비스 기획, UI 디자인 겸임 |
| 상급자 | 1 | 비 IT 직군 |

개발자는 나 하나다. 마이그레이션과 백엔드 전체를 혼자 담당한다.

서비스는 유전자검사 플랫폼이다. 사용자가 이용권을 등록하면 검사 키트가 배송되고, 검체를 수거해서 유전자 분석을 하고, W-GRS 점수 기반의 검사 결과를 앱으로 제공한다. 관리자 페이지에서는 이용권 발급, 키트 관리, 유전자 데이터 업로드, 검사 결과 확정, 회원 관리, 게시판 관리까지 전부 처리한다.

마이그레이션 대상인 기존 시스템은 PHP CodeIgniter로 만들어져 있었다. 입사 후 가장 먼저 한 일은 이 레거시의 규모를 파악하는 것이었다.

---

## 2. PHP 프로젝트의 규모

넘겨받은 PHP 프로젝트는 [CI Board](https://ciboard.co.kr/) 기반으로 커스텀된 구조였다. CI Board가 제공하는 게시판, 회원, 쇼핑몰 등의 기본 기능 위에 유전자검사 도메인을 얹은 형태다. CI Board 기본 기능 중 실제로 쓰지 않는 것도 상당수 남아 있었다.

규모는 API 컨트롤러 12개, Admin 컨트롤러 96개, 모델 115개. 서비스 계층이 없다. 컨트롤러가 모델을 직접 호출하고, 비즈니스 로직이 컨트롤러 안에 흩어져 있다.

---

## 3. 왜 새로 만들어야 했나

회사가 마이그레이션을 결정한 건 기술 부채 때문만이 아니었다. 비즈니스 요구를 충족할 수 없었다.

### 새 유전자검사 상품을 팔 수 없다

회사가 새로운 유전자검사 플랜(상품)을 출시하려고 했다. 기존에는 하나의 검사 플랜만 있었는데, PRO/BASIC 같은 복수 플랜을 지원해야 했다. 플랜마다 검사 항목이 다르고, 가격이 다르고, 결과 표시 방식이 다르다.

문제는 기존 코드가 **단일 플랜을 전제**로 만들어져 있다는 것이었다. 이용권 테이블에 플랜 ID가 없다. 검사 결과 테이블에도 플랜 구분이 없다. "어떤 플랜으로 검사했는가"라는 정보 자체가 데이터 모델에 없었다. 기존 코드 위에 플랜 시스템을 얹는 건 빚 위에 빚을 쌓는 일이다 — 이게 회사가 마이그레이션을 결정한 핵심 이유였다.

### 하드코딩 문제

이용권 API 컨트롤러의 실제 패턴이다.

```php
// 이용권 상태 확인 — 매직넘버
if ($voucher['vou_state'] == 1) {
    // 사용 가능
} else if ($voucher['vou_state'] == 2) {
    // 이미 사용됨
}
```

`1`이 "사용 가능"이고 `2`가 "사용됨"이라는 건 코드를 읽어야만 알 수 있다. 상수도 없고, Enum도 없다. 동일한 매직넘버가 여러 컨트롤러에 흩어져 있었다.

더 심각한 건 외부 URL 하드코딩이었다.

```php
// 이용권 입력 시 특정 스토어 URL로 리다이렉트
$redirect_url = "https://smartstore.naver.com/특정스토어/products/12534316361";
```

판매 채널 URL이 PHP 코드에 하드코딩되어 있다. 스토어 URL이 바뀌면 코드를 수정하고 배포해야 한다. 새 판매 채널을 추가하려면 코드를 수정하고 배포해야 한다.

### exit 패턴 인증

PHP 프로젝트의 인증 방식이 독특했다.

```php
class Api_voucher extends CB_Controller
{
    public function __construct()
    {
        parent::__construct();
        $this->load->model('Member_model');

        // 토큰 인증: 실패 시 exit
        $token = $this->input->get_request_header('Authorization');
        $member = $this->Member_model->get_by_token($token);
        if (!$member) {
            echo json_encode(['status' => 'error', 'message' => '인증 실패']);
            exit;  // 여기서 스크립트 종료
        }
        $this->member = $member;
    }
}
```

생성자에서 토큰을 검증하고, 실패하면 `exit`로 스크립트를 종료한다. 미들웨어나 필터 같은 레이어 없이, 각 컨트롤러의 생성자에서 인증을 처리한다. 인증 로직을 수정하려면 12개 API 컨트롤러의 생성자를 전부 고쳐야 한다.

토큰 갱신 메커니즘도 없었다. 한 번 발급된 토큰은 만료될 때까지 유효하고, 만료되면 다시 로그인해야 한다. Refresh token 개념 자체가 없었다.

### 회원 API의 문자열 기반 검증

```php
// 회원 가입 시 폼 검증 규칙
$this->form_validation->set_rules('userid', '아이디',
    'trim|required|min_length[3]|max_length[20]|regex_match[/^[a-z0-9_]+$/]');
$this->form_validation->set_rules('password', '비밀번호',
    'trim|required|min_length[5]|callback__mem_password_check');
$this->form_validation->set_rules('nickname', '닉네임',
    'trim|required|min_length[2]|max_length[20]');
$this->form_validation->set_rules('sex', '성별',
    'trim|required|exact_length[1]');
$this->form_validation->set_rules('birthday', '생년월일',
    'trim|required|exact_length[10]');
```

검증 규칙이 문자열로 선언된다. `exact_length[1]`이 성별이고 `exact_length[10]`이 생년월일이라는 건 컨벤션이지 강제가 아니다. 타입 시스템의 도움이 없으니 실수 여지가 많다.

---

## 4. 기획은 있지만 기획서는 없다

기획자가 있었다. 하지만 마이그레이션 초기에는 디자인 작업에 집중하고 있었고, 기획 자체는 **"기존 서비스와 동일하게 간다"**가 전제였다. 기존과 동일하게 가는 것이 전제이니 별도 기획서가 필요하지 않았던 것이다.

문제는 "기존과 동일"이라는 전제가 마이그레이션에서는 성립하지 않는다는 점이었다. 기존 동작을 문서로 정리한 게 없으니 PHP 코드를 읽어서 파악해야 했다. "이 기능은 어떻게 동작해야 하나요?"라고 물어보면 "기존이랑 같게요"라는 답이 오는데, 기존이 어떻게 동작하는지는 코드만이 알고 있었다.

마이그레이션 과정에서 발견한 누락 기능들이 여럿 있었다. "이 API는 원래 어떤 조건에서 호출되나요?"에 대한 답을 아는 사람이 없는 경우도 있었다. 이전 개발자가 퇴사한 뒤 코드만 남은 상태. 결국 PHP 코드가 곧 스펙이었고, 레거시 분석과 기획 보완까지 마이그레이션의 일부가 되었다.

---

## 5. 마이그레이션 전략

두 가지 선택지가 있었다.

### 점진적 교체 (Strangler Fig)

기존 PHP 시스템을 유지하면서, 하나의 API씩 Spring Boot로 교체해나가는 방식. Martin Fowler의 Strangler Fig 패턴.

**장점**: 위험이 낮다. 하나씩 교체하니까 실패해도 기존 시스템이 돌아간다.

**단점**: PHP와 Spring Boot가 동시에 운영되는 기간이 길어진다. 세션 공유, DB 동시 접근, 배포 복잡도가 증가한다. 무엇보다 데이터 모델을 바꿀 수가 없다 — PHP가 기존 테이블 구조를 전제하고 있으니까.

### 병렬 구축 (Big Bang)

새 시스템을 처음부터 만들고, 준비가 되면 전환하는 방식.

**장점**: 데이터 모델을 새로 설계할 수 있다. 플랜 시스템, EAV 기반 결과 저장, JWT 인증 등 기존 구조에서 불가능했던 것들을 구현할 수 있다.

**단점**: 전환 시점까지 신규 시스템이 미완성이다. 병렬 개발 기간 동안 기존 시스템도 유지해야 한다.

**병렬 구축을 선택했다.** 이유는 단순했다 — 데이터 모델을 바꾸지 않으면 새 플랜을 팔 수 없다. 점진적 교체로는 플랜 시스템을 도입할 수가 없었다.

다만 완전한 Big Bang은 아니었다. 관리자 웹은 Thymeleaf로 내가 직접 만들었지만, 모바일 앱 FE는 기존 PHP API 응답 형식을 기대하고 있었다. 앱 FE를 동시에 전면 재작성할 수는 없었기 때문에 **레거시 호환 계층**을 두기로 했다.

```
기존 앱 FE (PHP 응답 형식 기대)
       ↓
레거시 호환 컨트롤러 (PHP 응답 형식을 Spring Boot로 재현)
       ↓
Spring Boot DomainService / Facade
       ↓
새 데이터 모델
```

기존 프론트엔드가 기대하는 응답 형식을 유지하면서, 내부 로직은 Spring Boot로 동작하게 만드는 전략이었다. 관리자 웹은 Thymeleaf + Spring Boot로 처음부터 새로 만들면서 레거시 호환 없이 깨끗하게 갈 수 있었다. 이 레거시 호환 계층에 대해서는 [Part 3](/posts/admin-controller-migration-legacy-compatibility/)에서 자세히 다룬다.

---

## 6. 돌아보며

마이그레이션을 하러 온 것이다. 회사가 PHP 시스템의 한계를 인지하고, Spring Boot로의 전환을 결정하고, 그 경험이 있는 사람을 찾은 결과가 내 입사였다.

입사 전에 예상한 것은 "PHP 코드를 Spring Boot로 옮기는 일"이었다. 실제로 마주한 것은 "기획서 없이 PHP 코드를 스펙 삼아 도메인을 파악하고, 데이터 모델을 재설계하고, 관리자 웹까지 직접 만드는 일"이었다. 마이그레이션의 범위가 코드 전환을 넘어서 서비스 재구축에 가까웠다.

정리하면 세 가지였다.

> 1. **마이그레이션의 동기는 비즈니스다.** 기술 부채만으로는 마이그레이션을 정당화하기 어렵다. "이걸 바꾸지 않으면 새 매출이 불가능하다"가 회사가 전환을 결정한 실제 이유였다.
>
> 2. **레거시 분석이 마이그레이션의 절반이다.** 기획서가 없으니 PHP 코드가 곧 스펙이었다. 12개 API, 96개 Admin 컨트롤러, 115개 모델을 읽고 도메인 규칙을 파악하는 데 전체 일정의 상당 부분을 썼다.
>
> 3. **마이그레이션이라고 해서 마이그레이션만 하는 건 아니다.** 관리자 웹은 Thymeleaf로 직접 만들고, 누락된 기획은 직접 보완하고, FE와 API 스펙을 합의하는 것까지 전부 한 사람의 일이었다. 마이그레이션 인력으로 들어왔지만 실상은 서비스 전체를 다시 세우는 것이었다.

다음 글에서는 115개 PHP 모델을 44개 Spring Boot 엔티티로 재설계한 과정을 기록한다.

---

**시리즈:**
- **Part 1 (이 글)** — 왜 다시 만들었나
- [Part 2](/posts/php-to-spring-boot-domain-redesign/) — 도메인 재설계
- [Part 3](/posts/admin-controller-migration-legacy-compatibility/) — 레거시 호환과 신규 API
- [Part 4](/posts/spring-boot-infrastructure-auth-security/) — 인증, 보안, 인프라
- [Part 5](/posts/migration-lessons-learned-retrospective/) — 교훈과 수치
