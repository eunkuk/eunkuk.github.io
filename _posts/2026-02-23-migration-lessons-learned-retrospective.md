---
title: "1인 개발로 마이그레이션을 끝내며 — 마이그레이션 회고 (5) 교훈과 수치"
date: 2026-02-23 22:00:00 +0900
categories: [Dev, Migration]
tags: [retrospective, migration, spring-boot, php, lessons-learned, 1-person-dev]
description: "PHP CodeIgniter에서 Spring Boot로의 마이그레이션을 마무리하며. 최종 수치 비교, 마이그레이션하지 않은 것들, 1인 개발의 현실, 그리고 다시 한다면 다르게 할 것들."
---

> PHP CodeIgniter에서 Spring Boot로의 마이그레이션을 마무리하며. 최종 수치 비교, 마이그레이션하지 않은 것들, 1인 개발의 현실, 그리고 다시 한다면 다르게 할 것들.

---

## 1. 진짜 변화는 0에서 생긴 것들

마이그레이션 전후를 수치로 보면 줄어든 것이 눈에 띈다 — 컨트롤러, 모델 모두 절반 이하로 줄었다. 하지만 진짜 변화는 숫자가 줄어든 것이 아니라, **0에서 생긴 것들**이다.

| 항목 | Before (PHP) | After (Spring Boot) |
|------|-------------|-------------------|
| 서비스 계층 | 없음 | DomainService + Facade |
| 모듈 구조 | 단일 프로젝트 | 6모듈 멀티모듈 |
| API 문서 | 없음 | Swagger 자동 생성 |
| 캐시 | 없음 | Caffeine |
| 감사 추적 | 수동 | Hibernate Envers 자동 |

서비스 계층, 모듈 구조, API 문서, 캐시, 자동 감사 추적 — PHP에 없던 것들이 Spring Boot에 생겼다. 6모듈 구조의 설계 배경은 [모노레포 + 6모듈 구조](/posts/monorepo-multi-module-retrospective/)에서 자세히 다뤘다.

---

## 2. 마이그레이션하지 않은 것들

모든 것을 옮기지는 않았다. 제외한 이유는 세 가지로 나뉜다. **핵심 도메인이 아닌 것**(Cmall 쇼핑몰, Homepage 고객센터 등)은 별도 시스템으로 분리하거나 제거했다. **재설계가 필요한 것**(포인트, 결제)은 기존 구조를 옮기는 것보다 나중에 새로 만드는 게 나아서 보류했다. **더 이상 필요하지 않은 것**(Config, Stat, 중복 모델)은 `application.yml`이나 외부 도구로 대체하고 제거했다. 마이그레이션은 모든 것을 옮기는 일이 아니라, 옮길 것과 버릴 것을 판단하는 과정이기도 했다.

---

## 3. 1인 개발의 현실

### 마이그레이션 인력으로 왔지만

마이그레이션을 하러 입사했다. 공식 역할은 PHP → Spring Boot 전환 담당 백엔드 개발자다. 하지만 순수 백엔드 개발은 절반도 안 됐다. 나머지는 PHP 레거시 분석, 누락된 기획 보완, FE와의 API 스펙 합의, 관리자 웹 직접 개발(Thymeleaf), 인프라, 문서화였다. "마이그레이션 담당"으로 들어왔지만 실상은 서비스 전체를 다시 세우는 일이었다.

### 비IT 상급자와의 소통

상급자가 IT 직군이 아니라 기술적 결정에 대한 이해와 지지를 얻는 데 추가 비용이 든다.

"왜 기존 시스템을 유지하면서 새 시스템을 만드는 데 시간이 오래 걸리나요?"라는 질문에 "레거시 호환 계층이 필요하고, 데이터 모델 재설계에 시간이 들기 때문입니다"라고 답하면 통하지 않는다.

"기존 앱이 계속 돌아가야 하니까 새 시스템이 기존 형식도 지원해야 합니다. 그래서 두 가지를 동시에 만들고 있습니다"가 통한다.

기술 용어를 빼고 비즈니스 영향으로 설명하는 번역 능력이 필요했다.

### FE 조율

모바일 앱 프론트엔드 개발자와의 API 스펙 합의는 Swagger가 도입된 후 크게 개선됐다. 하지만 레거시 호환 API와 신규 API가 공존하는 과도기에는 혼란이 있었다.

```
"이 엔드포인트는 레거시 형식인가요, 새 형식인가요?"
"v0은 레거시, v1은 새 형식입니다."
"둘 다 Swagger에 있는데 어떤 걸 써야 하나요?"
```

네이밍으로 구분하는 것만으로는 부족했다. Swagger의 Tag 기능으로 "레거시 호환"과 "신규"를 시각적으로 분리했다.

---

## 4. 레거시 호환 계층의 미래

레거시 호환 컨트롤러가 운영 중이다. 앱 FE가 새 API로 전환되면 레거시 호환 컨트롤러를 퇴역시킬 수 있다. 관리자 웹은 Thymeleaf로 처음부터 새로 만들었기 때문에 레거시 호환이 없고, 퇴역 대상은 전부 앱 FE 대응 API다.

퇴역의 핵심은 실제로 호출이 0인 것을 확인한 후 제거하는 것이다. "아마 안 쓸 거예요"는 근거가 아니다. 트래픽을 모니터링하고, 레거시 호출이 없는 것을 확인한 뒤에야 안전하게 제거할 수 있다.

---

## 5. 돌아보며

마이그레이션을 하러 입사했다. 회사가 PHP 시스템의 한계를 인지하고, Spring Boot 전환을 결정하고, 그 경험이 있는 사람을 찾은 결과가 내 입사였다.

입사 전에 예상한 것은 "PHP 코드를 Spring Boot로 전환하는 일"이었다. 실제로 마주한 것은 "기획서 없이 PHP 코드를 스펙 삼아 도메인을 파악하고, 데이터 모델을 재설계하고, 관리자 웹까지 Thymeleaf로 직접 만드는 일"이었다. 마이그레이션 담당으로 들어왔지만 실상은 서비스를 다시 세우는 것이었다.

새 플랜을 팔 수 있게 됐다. API 문서가 생겼다. 캐시가 생겼다. 감사 추적이 자동화됐다. 비즈니스 규칙이 DomainService 한 곳에 집중됐다. 이전에 불가능했던 것들이 가능해졌다.

핵심 교훈 세 가지.

> 1. **마이그레이션은 번역이 아니라 재설계다.** PHP 115개 모델을 Java 115개 엔티티로 옮기는 건 마이그레이션이 아니다. 도메인을 이해하고 새 구조로 재설계하는 것이 마이그레이션이다. 115개가 44개가 된 것은 줄인 게 아니라 다시 만든 것이다.
>
> 2. **마이그레이션 인력 ≠ 마이그레이션만 하는 인력이다.** 관리자 웹을 Thymeleaf로 직접 만들고, 누락된 기획을 보완하고, FE와 API 스펙을 합의하는 것까지 전부 한 사람의 일이었다. 마이그레이션을 하러 온 사람이 서비스 전체를 다시 세우는 현실을 각오해야 한다.
>
> 3. **인프라 전환이 마이그레이션의 절반이다.** 도메인 로직 전환만 생각하면 일정의 절반을 놓친다. 인증(JWT), 보안(메뉴 기반 인가), 캐시(Caffeine), 감사(Envers), 문서(Swagger) — 이 "보이지 않는" 인프라가 전체 품질을 결정한다.

이전에 쓴 글들이 이 마이그레이션의 각 결정을 더 깊이 다루고 있다.

- [모노레포 + 6모듈 구조를 선택한 경위](/posts/monorepo-multi-module-retrospective/) — 왜 6모듈인가
- [Facade는 왜 Application 레이어에 있는가](/posts/spring-boot-facade-transaction-architecture/) — 트랜잭션 경계
- [EAV vs JSONB 마이그레이션](/posts/eav-vs-jsonb-gene-data-retrospective/) — 검사 결과 저장 방식
- [JWT 로그아웃 무효화](/posts/jwt-invalidation-without-redis/) — Redis 없이 토큰 무효화
- [경량 CQRS](/posts/lightweight-cqrs-facade-separation/) — Command/Query 분리

마이그레이션이 끝난 건 아니다. 레거시 호환 컨트롤러가 퇴역하고, 쇼핑몰이 분리되고, 통합 테스트가 채워지면 — 그때가 진짜 끝이다. 하지만 "새 상품을 팔 수 있는가"라는 질문에는 이제 "네"라고 답할 수 있다. 마이그레이션을 하러 왔고, 그 목적은 달성했다.

그리고 어드민을 개발하면서 한 가지 더 보이기 시작한 것이 있었다. 유전자 데이터 업로드 과정이다. 연구원이 분석 파이프라인을 수동으로 돌리고, 결과 파일을 어드민에서 직접 업로드하는 구조 — 이 과정 자체를 자동화할 수 있지 않을까? 이 생각이 [GeneTitan Agent](/posts/genetitan-agent-retrospective/)로 이어졌다.

---

**시리즈:**
- [Part 1](/posts/php-codeigniter-spring-boot-migration-why/) — 왜 다시 만들었나
- [Part 2](/posts/php-to-spring-boot-domain-redesign/) — 도메인 재설계
- [Part 3](/posts/admin-controller-migration-legacy-compatibility/) — 레거시 호환과 신규 API
- [Part 4](/posts/spring-boot-infrastructure-auth-security/) — 인증, 보안, 인프라
- **Part 5 (이 글)** — 교훈과 수치
