---
title: "1:N 강의 동시 번역 시스템 PoC 회고"
date: 2025-02-02 22:00:00 +0900
categories: [Dev, Backend]
tags: [realtime, translation, sse, vad, ordering, spring-boot, concurrency, tts, redis, retrospective]
description: "실시간 동시 번역 시스템을 구현하며 겪은 핵심 문제와 해결 과정을 정리했다. 포인트는 모델이 아니라 Order/Commit/Boundary 설계였다."
---

실시간 동시 번역 시스템을 만든다고 하면 보통 이렇게 시작한다.

- 실시간이니까 WebSocket?
- 음성 스트리밍이니까 WebRTC?

나도 처음엔 그렇게 생각했다.  
그런데 구현을 시작하고 나서 바로 깨달은 건, 이 프로젝트의 본질은 "전송 기술 선택"이 아니라 **문장 단위로 확정하고, 순서 있게 전달하는 비동기 제어**였다.

## 요구사항은 단순해 보였지만, 핵심은 경계 정의였다

초기 요구사항은 명확했다.

1. 1명의 강사 음성을 받는다.
2. STT로 텍스트화한다.
3. 문장이 완성되면 번역(+TTS)한다.
4. 5초 이상 무음이면 강제 번역(커밋)한다.
5. 결과를 SSE로 N명의 청취자에게 전달한다.
6. 강의 종료 시 전체 텍스트를 요약/정리한다.

문제는 2~5번이었다.

- STT 응답은 랜덤 지연이 있다.
- 네트워크는 도착 순서를 보장하지 않는다.
- 언어별 번역 속도는 다르다.
- TTS는 또 다른 비동기 작업이다.

즉, "잘 연결하기"보다 **언제 확정(Commit)하고, 어떤 순서(Order)로, 어디서 책임(Boundary)을 나눌지**가 먼저였다.

## 아키텍처 흐름

```text
Speaker Client (VAD)
  -> Ingest API (chunk + sequence)
  -> Session Buffer (in-memory queue)
  -> Ordered Drain (expected sequence)
  -> STT
  -> Sentence Commit (isFinal OR 5s silence from last VAD)
  -> Translation (per language async)
  -> TTS (per language async)
  -> SSE Broadcast
  -> Redis History (late join / reconnect)
```

## 전환점: FE가 만든 order도 그대로 믿으면 깨진다

초기에는 프론트에서 VAD 기준으로 sequence를 부여해 올렸고, 서버가 그 값을 기준으로만 정렬하면 된다고 봤다.

그런데 운영 로그에서 이상 현상이 나왔다.

- 문맥이 갑자기 끊기는 STT 결과
- 강제 커밋(5초 무음) 타이밍이 비정상적으로 발동
- 번역 결과 순서가 특정 구간에서 역전

원인은 "order 값이 틀렸다"가 아니었다.  
**Spring Boot 멀티스레드 환경에서 서버 내부 공유 상태가 레이스로 깨진 것**이었다.

핵심은 이거다.

- FE sequence는 좋은 힌트다.
- 하지만 순서 처리의 최종 책임은 서버다.
- 데이터에 order가 있어도, 처리가 동시성에 깨지면 품질은 무너진다.

## 해결: 세션 단위 인메모리 큐 + 단일 순서 처리 모델

외부 큐(Kafka/Redis Ordering)도 검토했지만, 이 단계에서는 오버엔지니어링이라고 판단했다.

- 구조: 1세션 1강사 발화
- 목표: 네트워크 홉 최소화, 지연 상한 관리
- 운영 복잡도: 현 규모에서 과도한 분산 인프라 회피

그래서 처리 모델을 이렇게 바꿨다.

1. API 스레드는 enqueue만 수행한다.
2. 세션 버퍼는 `expected sequence`부터 drain한다.
3. 정렬/커밋 상태 갱신은 세션 단위로 원자성 보장한다.

이때 비관적 접근(세션 단위 락)을 고민한 이유는 명확했다.

- 정렬 -> drain -> 커밋 판정은 복합 단계
- 중간에 끼어들면 정합성 깨짐
- 실시간 시스템에서 재시도 비용이 큼

다만 락을 길게 잡으면 지연이 폭증한다.  
그래서 원칙을 고정했다.

- 락은 상태 정리에만 짧게 사용
- 느린 외부 호출(STT/번역/TTS)은 락 밖에서 비동기 실행

## 커밋 정책이 시스템을 살렸다: isFinal + 5초 무음

문장 확정은 다음 두 조건으로 정책화했다.

1. STT가 `isFinal`을 주면 커밋
2. 마지막 VAD 발화 이후 5초 무음이면 강제 커밋

여기서 기준을 "마지막 STT 응답"이 아니라 "마지막 VAD 이벤트"로 둔 게 중요했다.

- STT 응답은 지연/역전 가능
- VAD 발화 신호는 사용자 행동에 더 직접적

이 정책으로 파이프라인이 멈추는 구간을 크게 줄였다.

## Partial/Final과 TTS 전달 전략을 분리해 충돌을 줄였다

초기에 고민이 많았던 부분이 이벤트 단위였다. 최종 전략은 아래처럼 정리했다.

- Partial: 빠른 텍스트 피드백
- Final: 확정 텍스트 + TTS 결합 이벤트

이렇게 분리하니,

- 즉시성(Partial)과 완성도(Final)를 동시에 가져갈 수 있었고
- 클라이언트는 "최종 문장 경험"을 명확히 처리할 수 있었다

## SSE, 재연결, 중간 입장: 서비스 완성도를 만든 마지막 20%

전송은 SSE를 사용했다. 이유는 단순했다.

- 청취자는 수신 중심
- 브로드캐스트에 적합
- 운영 단순성

대신 SSE의 빈틈은 서버에서 채웠다.

- Redis에 히스토리(주로 Final 이벤트) 저장
- 중간 입장: snapshot 후 live attach
- 재연결: Last-Event-ID 기반 복구

실시간 스트림과 종료 후 요약/정리 파이프라인도 분리했다.

- Live: 지연 상한 우선
- Archive: 정합성 우선

## 실제로 오래 고민했던 지점들

### 1) FE order를 어디까지 신뢰할 것인가

처음엔 "프론트가 sequence를 주니까 해결됐다"라고 생각했는데, 실제론 그렇지 않았다.  
결국 정리한 기준은 이거였다.

- FE sequence는 신뢰하되 검증한다
- 서버는 세션별 `expected sequence`로 최종 순서를 확정한다
- 중복/역전/과도한 지연 청크는 정책적으로 처리한다(버퍼 대기, 스킵, 드롭)

즉, 프론트는 순서를 "생성"하고 서버는 순서를 "보장"한다.

### 2) 락은 어디까지 걸고, 어디서 풀 것인가

이 구간이 성능과 정합성의 충돌 지점이었다.

- 락 안에서 해야 하는 것: 버퍼 삽입, expected seq 갱신, drain 판단, 커밋 상태 갱신
- 락 밖으로 빼야 하는 것: STT 호출, 번역 호출, TTS 호출

락을 넓게 잡으면 안전하지만 지연이 폭증하고, 락을 좁히면 빠르지만 레이스가 터진다.  
그래서 "세션 단위로 짧게 잠그고, 느린 I/O는 전부 락 밖 비동기"로 고정했다.

### 3) 5초 무음은 기술 상수가 아니라 서비스 정책이었다

5초는 수학적으로 완벽한 값이 아니라, 품질/지연/비용의 경계선이었다.

- 너무 짧으면 문장을 잘라먹어 품질이 떨어진다
- 너무 길면 사용자는 결과가 멈췄다고 느낀다
- 무음 기준은 STT 응답이 아니라 마지막 VAD 발화 이벤트로 잡아야 흔들림이 적다

결국 커밋 규칙은 "정확한 이론값"보다 "운영 가능한 UX 기준"으로 확정했다.

### 4) Partial/Final/TTS를 어떻게 묶을 것인가

여기도 꽤 오래 고민했다.

- Partial까지 TTS를 붙이면 비용과 지연이 크게 늘어남
- Final만 TTS를 붙이면 사용자 경험이 안정적임

그래서 최종 전략을 다음처럼 분리했다.

- Partial: 빠른 텍스트 피드백
- Final: 확정 텍스트 + TTS 결합 이벤트

이 분리 덕분에 즉시성과 완성도를 동시에 가져갈 수 있었다.

### 5) Redis 히스토리를 어디까지 저장할 것인가

중간 입장/재연결을 위해 히스토리는 필요했지만, 무엇을 저장할지는 별개 문제였다.

- Partial까지 저장하면 양이 급증하고 노이즈가 많다
- Final 중심으로 저장하면 재생성과 비용이 안정적이다

그래서 운영 기준은 "Final 우선 저장 + snapshot 이후 live attach"로 두었다.

### 6) Kafka/Redis Ordering을 언제 도입할 것인가

처음부터 분산 큐를 넣고 싶었지만, 이 프로젝트 단계에서는 오버엔지니어링이었다.

- 현재 구조: 1세션 1강사 발화
- 목표: 지연 상한과 운영 단순성
- 결론: 인메모리 세션 큐가 가장 실용적

대신 확장 조건은 명확히 잡아뒀다.  
세션 수와 처리량이 임계치를 넘으면 Ordering 레이어를 Redis/Kafka로 분리하는 방향으로 전환한다.

## 결론

이 프로젝트를 지나오며 확실해진 건 하나다.

비동기 프로그래밍의 정수는 `async/await` 문법이 아니다.  
동시에 움직이는 시스템에서 **Order / Commit / Boundary**를 설계하는 능력이다.

정리하면 이렇다.

1. FE order는 힌트일 뿐, 서버가 최종 질서를 보장해야 한다.
2. 커밋 규칙(`isFinal` + `5초 무음`)은 품질/지연/비용의 경계선이다.
3. 락은 상태 정리에만 짧게, 느린 I/O는 락 밖으로 빼야 실시간성이 산다.
4. 실시간 번역 시스템은 모델 이전에 흐름 제어 시스템이다.
